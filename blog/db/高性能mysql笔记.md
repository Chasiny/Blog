## mysql逻辑架构

## 锁粒度

* 表锁：开销最小，锁定整张表。一个用户获得写锁后，会阻塞其他用户对该表的所有读写操作。读锁之间不相互阻塞（写锁比读锁右更高优先级）．例如ALTER TABLE之类的操作，将会锁定整张表
* 行级锁：只在存储引擎层实现

## 选择优化的数据类型

* 更小的通常越好（占用更少的磁盘，内存和CPU缓存，并且处理时需要的cpu周期也更小）
* 简单就好
* 避免使用NULL。（当可为NULL时的列被索引时，每个索引记录需要一个额外的字节）
* 整形－>可以考虑使用BIGINT代替DECIMAL（乘以小数位数对应的倍数），避免浮点存储计算不精确和DECIMAL计算代价高
* 字符串：char适合短，接近定长，例如md5，不易产生碎片
* 使用枚举代替字符串类型
* 整数通常是标识列最好的选择

## 陷阱

* 太多列
* 太多关联
* 全能的枚举
* 变相枚举

# 索引

## B-Tree索引
> 索引对多个值进行排序的依据是create table语句中定义索引时列的排序
### 索引有效时
* 全值匹配
* 匹配最左前缀（只使用索引第一列）
* 匹配列前缀（匹配某一列的值的开头部分）
* 匹配范围值
* 精确匹配某一列并范围匹配另外一列
* 只访问索引的查询
### 限制
* 如果不是按照索引的最左列开始查找，则无法使用索引
* 不能跳过索引中的列
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找

## 哈希索引（只要精确匹配索引才有效）
* 哈希索引只包含哈希值和行指针，不存储字段值，但访问内存中的行速度很快
* 哈希索引数据不是按照数据值排序，因此无法用于排序
* 哈希索引不支持部分索引列匹配查找
* 哈希索引只支持等值比较查询，不支持任何范围查询
* 访问哈希索引的数据非常快，除非有很多哈希冲突（将会一个一个遍历）
* 如果哈希冲突很多的话，一些索引维护操作的代价会很高

## 创建自定义哈希索引

## 空间数据索引（R-Tree）

## 全文索引

## 其他索引类别

