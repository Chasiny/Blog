## Description
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

## Example 1:

```
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```

Example 2:
```
Input: "cbbd"
Output: "bb"
```

## 暴力
### 思路：
从头开始遍历，从后开始判断是不是回文字符串，加入部分剪枝  
### 时间复杂度
O(n^3)

```c++
class Solution {
public:
    int len;
    string src;
    int lPos;
    int rPos;
    bool check(int l,int r){
        for(;l<r;l++,r--){
            if(src[l]!=src[r]){
                return false;
            }
        }
        return true;
    }
    string longestPalindrome(string s) {
        len=0;
        src=s;
        for(int i=0;i<s.size();i++){
            if(s.size()-1-i<len){
                break;
            }
            for(int j=s.size()-1;j>=i+len;j--){
                if(j-i<len){
                    break;
                }
                if(check(i,j)){
                    len=j-i+1;
                    lPos=i;
                    rPos=j-i+1;
                    break;
                }
            }
        }
        
        return s.substr(lPos,rPos);
    }
    
};
```

## 中心扩展
### 思路：
从头开始遍历，从遍历的位置开始向左右扩展，直到左右不相等或者到达边界  
### 时间复杂度
O(n^2)

```c++
class Solution {
public:
    int l,r;
    int lPos,rPos;
    int len;
    string longestPalindrome(string s) {
        len=0;
        
        for(int i=0;i<s.size();i++){
            l=r=i;
            while(r<s.size()&&s[r+1]==s[r]){
                r++;
            }
            i=r;
            while(l>=0&&r<s.size()&&s[l]==s[r]){
                l--;
                r++;
            }
            if(r-l>len){
                lPos=l+1;
                rPos=r-1;
                len=r-l;
            }
            
        }
        
        return s.substr(lPos,rPos-lPos+1);
    }
};
```